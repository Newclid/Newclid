/**
   Copyright 2025 Concordance Inc. dba Harmonic

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
// Define the test module name for Boost.Test
#define BOOST_TEST_MODULE point_test

// Include necessary Boost.Test headers
#include <boost/test/unit_test.hpp>
#include <boost/test/data/test_case.hpp>
#include <boost/test/data/monomorphic/collection.hpp>

// Include the headers for the classes being tested
#include "type/point.hpp"
#include "problem.hpp"

// Include standard library headers used in tests
#include <vector>
#include <string>
#include <algorithm> // For std::sort, though not strictly used in current tests
#include <sstream>   // For std::stringstream in ostream tests

// Use the Yuclid namespace to avoid verbose prefixes
using namespace Yuclid;
// Use the std namespace for common standard library elements, as requested for GNU style
using namespace std;
// Enable string literals.
using namespace std::string_literals;


/**
 * @brief A fixture to ensure the global problem instance is cleared before and after each test.
 *
 * This is crucial for testing thread-local singletons like `problem`, as it ensures
 * that each test case starts with a clean and isolated problem state.
 */
struct ProblemClearFixture {
  /**
   * @brief Constructor for the fixture.
   * Clears the thread-local problem instance before a test runs.
   */
  ProblemClearFixture() {
    // Call the public static reset method
    problem::reset();
  }

  /**
   * @brief Destructor for the fixture.
   * Clears the thread-local problem instance after a test has completed.
   * This ensures a clean state for the next test if tests runs sequentially
   * in the same thread.
   */
  ~ProblemClearFixture() {
    // Call the public static reset method
    problem::reset();
  }
};

// Define a test suite and apply the ProblemClearFixture to it.
// All test cases within this suite will automatically use the fixture.
BOOST_FIXTURE_TEST_SUITE(point_suite, ProblemClearFixture)

/**
 * @brief Test case for point creation and direct index retrieval.
 */
BOOST_AUTO_TEST_CASE(point_creation_and_get_index) {
  Point p(10); // Create a point with index 10
  BOOST_CHECK_EQUAL(p.get(), 10); // Verify that the stored index is correct
}

/**
 * @brief Test case for point comparison operators.
 * Uses the default comparison generated by `operator<=>`.
 */
BOOST_AUTO_TEST_CASE(point_comparison) {
  Point p1(5);
  Point p2(10);
  Point p3(5);

  BOOST_CHECK(p1 < p2);      // 5 < 10
  BOOST_CHECK(p2 > p1);      // 10 > 5
  BOOST_CHECK(p1 == p3);     // 5 == 5
  BOOST_CHECK(p1 <= p3);     // 5 <= 5
  BOOST_CHECK(p1 >= p3);     // 5 >= 5
  BOOST_CHECK(p1 != p2);     // 5 != 10
}

/**
 * @brief Test case for accessing point data (name, x, y) through the problem instance.
 * Points must be added to the global problem before their data can be accessed.
 */
BOOST_AUTO_TEST_CASE(point_data_access) {
  // Add points to the thread-local problem instance
  problem::add_point("A", static_cast<double>(1.0L), static_cast<double>(2.0L)); // Index 0
  problem::add_point("B", static_cast<double>(3.0L), static_cast<double>(4.0L)); // Index 1
  problem::add_point("C", static_cast<double>(5.0L), static_cast<double>(6.0L)); // Index 2

  Point p0(0); // Corresponds to "A"
  Point p1(1); // Corresponds to "B"
  Point p2(2); // Corresponds to "C"

  // Verify data access for point p0
  BOOST_CHECK_EQUAL(p0.name(), "A"s);
  BOOST_CHECK_EQUAL(p0.x(), static_cast<double>(1.0L));
  BOOST_CHECK_EQUAL(p0.y(), static_cast<double>(2.0L));

  // Verify data access for point p1
  BOOST_CHECK_EQUAL(p1.name(), "B");
  BOOST_CHECK_EQUAL(p1.x(), static_cast<double>(3.0L));
  BOOST_CHECK_EQUAL(p1.y(), static_cast<double>(4.0L));

  // Verify data access for point p2
  BOOST_CHECK_EQUAL(p2.name(), "C");
  BOOST_CHECK_EQUAL(p2.x(), static_cast<double>(5.0L));
  BOOST_CHECK_EQUAL(p2.y(), static_cast<double>(6.0L));
}

/**
 * @brief Test case for handling invalid point index access.
 * Methods accessing problem data should throw `std::out_of_range`.
 */
BOOST_AUTO_TEST_CASE(point_data_access_invalid_index) {
  // The fixture already ensures the problem is empty initially.
  Point p_invalid_empty(0); // Index 0 when problem is empty

  // Expect std::out_of_range when trying to access data for a non-existent point
  BOOST_CHECK_THROW(p_invalid_empty.name(), out_of_range);
  BOOST_CHECK_THROW(p_invalid_empty.x(), out_of_range);
  BOOST_CHECK_THROW(p_invalid_empty.y(), out_of_range);

  // Add one point, then check for an out-of-bounds index
  problem::add_point("D", static_cast<double>(7.0L), static_cast<double>(8.0L)); // Index 0
  Point p_still_invalid(1); // Index 1 does not exist after adding only one point

  // Expect std::out_of_range again
  BOOST_CHECK_THROW(p_still_invalid.name(), out_of_range);
  BOOST_CHECK_THROW(p_still_invalid.x(), out_of_range);
  BOOST_CHECK_THROW(p_still_invalid.y(), out_of_range);
}

/**
 * @brief Test case for the `point::all()` generator.
 * Verifies that it yields all existing points in order.
 */
BOOST_AUTO_TEST_CASE(point_all_generator) {
  // Add multiple points to the problem
  problem::add_point("P1", static_cast<double>(10.0L), static_cast<double>(11.0L)); // Index 0
  problem::add_point("P2", static_cast<double>(12.0L), static_cast<double>(13.0L)); // Index 1
  problem::add_point("P3", static_cast<double>(14.0L), static_cast<double>(15.0L)); // Index 2

  vector<point> all_points;
  // Iterate through the generator and collect all yielded points
  for (const auto& p : point::all()) {
    all_points.push_back(p);
  }

  BOOST_CHECK_EQUAL(all_points.size(), 3); // Check total count
  BOOST_CHECK_EQUAL(all_points[0].get(), 0); // Check indexes
  BOOST_CHECK_EQUAL(all_points[1].get(), 1);
  BOOST_CHECK_EQUAL(all_points[2].get(), 2);
  BOOST_CHECK_EQUAL(all_points[0].name(), "P1"); // Check names (indirectly verifies correct lookup)
  BOOST_CHECK_EQUAL(all_points[1].name(), "P2");
  BOOST_CHECK_EQUAL(all_points[2].name(), "P3");
}

/**
 * @brief Test case for `point::all()` when the problem is empty.
 * Ensures the generator yields no points.
 */
BOOST_AUTO_TEST_CASE(point_all_generator_empty_problem) {
  // Problem is cleared by the fixture, so it starts empty
  vector<point> all_points;
  for (const auto& p : point::all()) {
    all_points.push_back(p);
  }
  BOOST_CHECK(all_points.empty()); // Should be empty
}

/**
 * @brief Test case for the `point::up_to()` generator.
 * Verifies that it yields points with indexes strictly less than the target point's index.
 */
BOOST_AUTO_TEST_CASE(point_up_to_generator) {
  // Add points to ensure there are points to yield
  problem::add_point("Q0", static_cast<double>(0.0L), static_cast<double>(0.0L));
  problem::add_point("Q1", static_cast<double>(1.0L), static_cast<double>(1.0L));
  problem::add_point("Q2", static_cast<double>(2.0L), static_cast<double>(2.0L));
  problem::add_point("Q3", static_cast<double>(3.0L), static_cast<double>(3.0L));

  point target_point(3); // This point has index 3 (corresponds to Q3)

  vector<point> points_up_to;
  // Iterate through the generator for points strictly less than target_point
  for (const auto& p : target_point.up_to()) {
    points_up_to.push_back(p);
  }

  BOOST_CHECK_EQUAL(points_up_to.size(), 3); // Expect points with indexes 0, 1, 2
  BOOST_CHECK_EQUAL(points_up_to[0].get(), 0); // Check indexes
  BOOST_CHECK_EQUAL(points_up_to[1].get(), 1);
  BOOST_CHECK_EQUAL(points_up_to[2].get(), 2);
}

/**
 * @brief Test case for `point::up_to()` when the target point has index 0.
 * Ensures no points are yielded.
 */
BOOST_AUTO_TEST_CASE(point_up_to_generator_zero_index) {
  problem::add_point("R0", static_cast<double>(0.0L), static_cast<double>(0.0L)); // Add at least one point to make problem non-empty
  point target_point(0); // Target point with index 0
  vector<point> points_up_to;
  for (const auto& p : target_point.up_to()) {
    points_up_to.push_back(p);
  }
  BOOST_CHECK(points_up_to.empty()); // Should be empty as no index is strictly less than 0
}

/**
 * @brief Test case for `point::up_to()` with a larger index.
 * Verifies correct number of yielded points and their indexes.
 */
BOOST_AUTO_TEST_CASE(point_up_to_generator_large_index) {
  // Add 100 points
  for (int i = 0; i < 100; ++i) {
    problem::add_point("Point"s + to_string(i), static_cast<double>(i), static_cast<double>(i));
  }
  point target_point(50); // Target point with index 50

  vector<point> points_up_to;
  for (const auto& p : target_point.up_to()) {
    points_up_to.push_back(p);
  }
  BOOST_CHECK_EQUAL(points_up_to.size(), 50); // Expect points with indexes 0 to 49
  for (size_t i = 0; i < 50; ++i) {
    BOOST_CHECK_EQUAL(points_up_to[i].get(), i); // Verify each yielded index
  }
}


/**
 * @brief Test case for the `operator<<` (output stream) for `point` objects.
 * Verifies the formatting of the output.
 */
BOOST_AUTO_TEST_CASE(point_ostream_operator) {
  problem::add_point("TestPoint", static_cast<double>(12.34L), static_cast<double>(56.78L)); // Add a point
  Point p(0); // Point with index 0
  stringstream ss;
  ss << p; // Output point to stringstream

  // Expected output format: point(index, name, x=val, y=val)
  // Note: The 'double' precision in string output might vary slightly across compilers/platforms.
  // We check for exact string match here, which is usually fine for simple numbers.
  BOOST_CHECK_EQUAL(ss.str(), "point(0, TestPoint, x=12.34, y=56.78)");
}

/**
 * @brief Test case for `operator<<` when the point's index is invalid.
 * Ensures appropriate error message is printed.
 */
BOOST_AUTO_TEST_CASE(point_ostream_operator_invalid_index) {
  problem::reset(); // Ensure the problem is empty using the new public reset method
  Point p_invalid(99); // Invalid index
  stringstream ss;
  ss << p_invalid; // Output invalid point

  // Check if the output contains the expected "Invalid Index" message
  BOOST_CHECK(ss.str().find("Invalid Index") != string::npos);
}

// End of the test suite
BOOST_AUTO_TEST_SUITE_END()
